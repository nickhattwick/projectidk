<head>
  <style type="text/css">
    code { background-color: gray; color: blue; }
  </style>
</head>
<body>
  <p>At first glance it's hard to imagine how much logic is needed for JSON to convert objects into strings and strings into objects. It's easy to take for granted the ease of transferring objects between programs, but it's surprising how different JavaScript Object Notation is from a JavaScript string. At first glance, it appears that the object is just enclosed in quotation marks, however many characters and objects don't retain all of their aspects when being turned into a string through normal means. Thankfully, JSON has methods for turning objects into strings and vice versa, but what if it didn't?</p>
  <h2>To JSON</h2>
  <p>At it's core JSON is going to return a string containing an object. Using JavaScript's toString method, an Array will the brackets surrounding returning only the list inside. This may be easy to read for a person, but a program wouldn't know how to transform it back in object form since it wouldn't reference what kind of structure it was before. Turning an object into a string ends up with something unreadable to humans as well. Given these are the two types of objects that JSON is made to store, it wouldn't be very effective if it couldn't recognize them.</p>
  <p>In order to do this, a program would have to recognize what they are in object form and adjust their place in the string accordingly, manually adding the appropriate brackets, commas, and colons needed to process them. It then needs to interact with the different types of values and internal objects that make them, detecting what kind of structure it's dealing with and applying the appropriate function, all while creating a string that successfully captures everything necessary to run them. If it hits an array, it needs to call the items within the array. If it hits an object, it needs to capture both the keys and values by interacting with the object via the language to get the information it needs.</p>
  <p>Objects are naturally complex in this way, but even the process of maintaining a string within a stringified object can prove to be quite frustrating, since adding it normally would merge the strings losing the context of which items in the object were strings in the first place. While it might be easy to tell for a human, to JavaScript, "false" and false are very different things. A string containing a number is different from a number itself, and the spaces contained within a string wouldn't be processed by the language otherwise. Because of this, the function needs to manually add strings surrounding the contents of the string it's storing using backslashes to escape from the natural merging that would occur from adding one string to another. Instead of simply adding the contents to the output string, it would have to add '\"' + string contents + '\"' to be able to unpack correctly.</p>
  <p>Once the function has it's ways of processing objects, it will also need to go through and call the appropriate methods until it's input is stored. Recursion is necessary for this, since it will need to inspect and process and every object nested within that, running over and over until the whole string is stored. Luckily, the logic for numbers and booleans is the easiest since they can be easily added to the storage string by themselves with no special characters needed to be read, but the easiest things to store can end up being more difficult to unpack.</p>
  <h2>The Long Road Back</h2>
  <p>Alright, we're halfway there, right? We've climbed the mountain, now we just need to climb back down. If anything, it's more akin to a valley as making one long string from a series of objects is much simpler than turning one string into multiple types of objects. Why isn't there a function that just removes the quotation marks from a string. If there is, why don't I know about it? Regardless, it's time to dive in to making a functional object from a single string. In order to do this, a parsing function would require the ability to process any character thrown into it in the appropriate context. For the enclosing objects, this starts off simpler. If the first item of the string is "{" or "[", then it creates an object or an array respectively.</p>
  <p>From there, it would split off in how it processes the next key. If the first character was "{", it would look to make the first item after the bracket and before a colon into the key, and the item after the colon the value, and to begin the process again if it hit comma, handling keys and values until it hits a bracket, calling an object processing function recursively. Alternatively, if it had processed a "[", it would be looking to separate its items by comma's, creating and adding to an array until it hits the ending bracket. Of maybe it hits an array within an object of vice versa. The program needs to be able to call the function it needs as it hits a new item, resulting in functions made to process arrays, objects, strings, numbers and booleans along with other possibilities such as null.</p>
  <p>While a string is fairly simple, adding every character between the strings into a string, booleans and null must be checked in their entirety in order as opposed to being added a character at a time, though luckily there aren't too many words that can be stored outside of strings. Similar logic applies to numbers, although in order to take multiple numbers out of a string, the whole number will require the number function since single numbers can't just be placed together to make a multiple digit number. (Number("100") instead of 1 + 0 + 0).</p>
  <p>For the most part, that's the process of converting a JSON object to a string. Except for one last character, "\". The backslash isn't actually considered a character and just serves to maintain the presence of another character that couldn't normally be in a string. Even in JSON, the escape key continues serving it's function as opposed to being treated as a regular string, meaning that the process of converting a string with escape keys to JSON requires escaping each escape key with another one. For instance, if you wanted to capture the string ('They call me \"Bob\"'), each character needing an escape would need another one to be stored in another string, resulting in (<span style="color:#800080;">\</span>"They call me <span style="color:#800080;">\</span>\<span style="color:#800080;">\</span>"Bob<span style="color:#800080;">\</span>\<span style="color:#800080;">\</span>") being captured in the JSON's larger string. Breaking it back out requires removing every backslash unless it has a backslash in front of it, that isn't being cancelled out by another backslash.</p>
  <h2>Conclusion</h2>
  <p>All in all, while looking like a simple addition of quotation marks, there's a lot more that needs to be done in converting an object to a parseable string and parsing it. Thankfully, JSON has functions to do this for us, but when being newer programming it can be surprising to see how different a string can be from what was put into it. Even having a rough idea of this, rewriting JSON functions is an interesting experience to see what JSON does for us and just how crazy it would be transferring data between languages and formats without it.</p>
</body>
